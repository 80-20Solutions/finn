import 'package:dartz/dartz.dart';
import '../../../../core/errors/failures.dart';
import '../entities/group_expense_assignment_entity.dart';
import '../repositories/budget_repository.dart';

/// Use case for assigning group expenses to user's personal budget
///
/// Implements FR-011, FR-012, FR-013:
/// - FR-011: Create group expense assignment when user joins group
/// - FR-012: Group expenses deducted from available budget
/// - FR-013: Only one active assignment per user per group
///
/// Part of User Story 3: Group Membership and Expense Assignment
class AssignGroupExpensesUseCase {
  final BudgetRepository repository;

  AssignGroupExpensesUseCase(this.repository);

  /// Assign or update group expense limit for a user
  ///
  /// Business rules:
  /// - Only one active assignment per user per group (FR-013)
  /// - Amount must be non-negative (FR-003)
  /// - Deducts from available budget (FR-012)
  /// - May trigger automatic savings adjustment (handled by watcher)
  ///
  /// Returns the created/updated assignment on success
  Future<Either<Failure, GroupExpenseAssignmentEntity>> call({
    required String userId,
    required String groupId,
    required int spendingLimit,
  }) async {
    // Validate spending limit is non-negative
    if (spendingLimit < 0) {
      return Left(
        ValidationFailure('Spending limit cannot be negative'),
      );
    }

    // Validate IDs are not empty
    if (userId.trim().isEmpty) {
      return Left(ValidationFailure('User ID cannot be empty'));
    }

    if (groupId.trim().isEmpty) {
      return Left(ValidationFailure('Group ID cannot be empty'));
    }

    try {
      // Check if assignment already exists (FR-013: one per user per group)
      final existingResult =
          await repository.getGroupExpenseAssignment(userId, groupId);

      return await existingResult.fold(
        // No existing assignment - create new one
        (failure) async {
          final newAssignment = GroupExpenseAssignmentEntity(
            id: '', // Will be generated by repository
            userId: userId,
            groupId: groupId,
            spendingLimit: spendingLimit,
            createdAt: DateTime.now(),
            updatedAt: DateTime.now(),
          );

          return await repository.createGroupExpenseAssignment(newAssignment);
        },
        // Existing assignment found - update it
        (existingAssignment) async {
          final updatedAssignment = GroupExpenseAssignmentEntity(
            id: existingAssignment.id,
            userId: userId,
            groupId: groupId,
            spendingLimit: spendingLimit,
            createdAt: existingAssignment.createdAt,
            updatedAt: DateTime.now(),
          );

          return await repository.updateGroupExpenseAssignment(
            updatedAssignment,
          );
        },
      );
    } catch (e) {
      return Left(
        ServerFailure('Failed to assign group expenses: ${e.toString()}'),
      );
    }
  }

  /// Remove group expense assignment when user leaves group
  ///
  /// Per FR-020/FR-021:
  /// - Retains group expense category in budget
  /// - Removes group views/features access
  /// - User can manually adjust budget afterward
  ///
  /// Returns Unit on success
  Future<Either<Failure, Unit>> removeAssignment({
    required String userId,
    required String groupId,
  }) async {
    // Validate IDs are not empty
    if (userId.trim().isEmpty) {
      return Left(ValidationFailure('User ID cannot be empty'));
    }

    if (groupId.trim().isEmpty) {
      return Left(ValidationFailure('Group ID cannot be empty'));
    }

    try {
      // Get existing assignment
      final existingResult =
          await repository.getGroupExpenseAssignment(userId, groupId);

      return await existingResult.fold(
        // No assignment found - nothing to remove
        (failure) => const Right(unit),
        // Assignment found - delete it
        (assignment) async {
          return await repository.deleteGroupExpenseAssignment(assignment.id);
        },
      );
    } catch (e) {
      return Left(
        ServerFailure('Failed to remove group assignment: ${e.toString()}'),
      );
    }
  }

  /// Get current group expense assignment for user
  ///
  /// Returns None if user not in any group with expense assignment
  /// Returns assignment details if exists
  Future<Either<Failure, GroupExpenseAssignmentEntity?>> getAssignment({
    required String userId,
    required String groupId,
  }) async {
    // Validate IDs are not empty
    if (userId.trim().isEmpty) {
      return Left(ValidationFailure('User ID cannot be empty'));
    }

    if (groupId.trim().isEmpty) {
      return Left(ValidationFailure('Group ID cannot be empty'));
    }

    try {
      final result = await repository.getGroupExpenseAssignment(userId, groupId);

      return result.fold(
        // No assignment found
        (failure) => const Right(null),
        // Assignment found
        (assignment) => Right(assignment),
      );
    } catch (e) {
      return Left(
        ServerFailure('Failed to get group assignment: ${e.toString()}'),
      );
    }
  }
}
